# 《C++ prime plus 第六版》
## 目录
[第1章 预备知识](#1)
[第2章 开始学习C++](#2)
[第3章 处理数据](#3)
[第9章 内存模型和名称空间](#9)

[toc]

## <a id="1">第1章 预备知识</a>
- 小节标题
  - 1.1 C++简介
  - 1.2 C++简史
  - 1.3 可移植性和标准 
  - 1.4 程序创建的技巧
- 知识点总结
  - C++融合了三种不同的编程方式：**过程性语言**、**面向对象语言**、**泛型编程**
  - C目前标准：C99，C11；C++目前标准：C++98、C++11
  - 集成开发环境(IDE)、命令行环境

    <img src="./images/cplus_0.jpg" width="80%">

- 重要问题

    Q: 一个C++程序是如何运行起来的（P6）？

    使用**文本编辑器**编写程序，并将其保存到文件中，这个文件是程序的**源代码**。**编译**源代码，即意味着运行一个程序，将源代码翻译为机器语言，包含了翻译后的程序文件是程序的**目标代码**(objct code)。将目标代码与其他代码**链接**起来，链接指的是将目标代码同时用的函数的目标代码以及一些标准的启动代码(startup code)组合起来，生成程序的运行阶段版本，包含该最终产品的文件被称为**可执行文件**。

    <img src="./images/cplus_1.jpg" width="60%">

    Q: Linux中的编译和链接是什么样的（P8）？

## <a id="2">第2章 开始学习C++</a>
- 小节标题
  - 2.1 开始学习C++
  - 2.2 C++语句
  - 2.3 其他C++语句
  - 2.4 函数
- 知识点总结
  - `#incldue <iostream>` 编译指令导致预处理器将iostream头文件的内容添加到程序中，使用cin和cout进行输入和输出的程序必须包含文件iostream
  - `#include <file>`编译程序会先到标准函数库中找文件；`#include "file" `编译程序会先从当前目录中找文件
  - `using namespace std`表示可以使用名称空间std中的所有名称，但更好的方法是只使用所需的名称，如`using std::cout`
  
    <img src="./images/cplus_2.jpg" width="80%">

  - 一行代码中不可分割的元素叫做**标记**。空白、制表符、和回车统称为**空白**，通常，必须用空白将标记分开。
  - 对于声明变量，C++的做法是尽可能在首次使用变量前声明它，函数原型之于函数就像变量声明之于变量——指出涉及的类型。
  - **函数**由函数头和函数体组成。**函数头**指出函数的返回值类型和函数期望通过参数传递给它的信息类型。**函数体**由一系列位于花括号中的C++语句组成。**参数**是发送给函数的信息，**返回值**是从函数中发送回去的值
  - 在有些语言中，有返回值的函数被称为函数(function)；没有返回值的函数被称为过程(procedure)或子程序(subroutine)，但C++和C一样都称为函数。
  - main()返回一个int值，而程序员要求它返回整数0
  - 程序员有时将函数比作一个由出入他们信息所指定的黑盒子(black boxes)(电工用语)
    
    <img src="./images/cplus_3.jpg" width="80%">


## 第3章 处理数据
- 小节标题
  - 3.1 简单变量
  - 3.2 const 限定符
- 知识点总结
  - C++的基本整型（按照宽度递增顺序排列）分别是char（字符和小整数）,short,int,long和C++新增的long long,其中每种类型都有符号版本和无符号版本，共10种类型。char在默认情况下既不是没有符号，也不是有符号。
  - 如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的
  - C++对字符使用单引号，对字符串使用双引号
  - [const](#const) 比 #define 好，首先它明确指定类型；其次可以使用C++作用域规则将定义限制在特定的函数或文件中
- 重要问题
  Q: C++变量命名规则？(P33)
  Q: C++整型变量长度标准？(P34)
  Q: C++11提供的大括号初始化？(P37)
  Q: 通用字符名，wchar_t，以及C++11新增的char16_t和char32_t的使用？（P44-45）

## 第9章 内存模型和名称空间
- 小节标题
- 知识点总结
    - 基于预处理器编译指令#ifndef(即if not define)是避免多次包含同一头文件的标准C/C++技术
    - **存储持续性**，即存储类别如何影响在文件间的共享；**作用域**(scope)描述了名称在文件(翻译单元 translation unit)的多大范围可见；**链接性**(linkage)描述了名称如何在不同单元间共享
    - **自动存储持续性**，在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放；**静态存储持续性**，在程序整个执行过程中都存在。
    - 链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件，也称**全局变量**.
    - 在多文件程序中，可以在一个文件中（且只能在一个文件中）定义一个外部变量，使用该变量的其他文件必须使用关键字extern声明它。
    - 编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量（栈），另外一块用于动态储存
    - 有些被称为**存储说明符**(storge class specifier)或**cv-限定符**(cv-specifier)的C++关键词提供了其他有关存储的信息
    - C++是通过定义一种新的`声明区域`来创建命名的**名称空间**，以减少名称冲突

      <img src="./images/cplus_4.jpg" width="80%">

- 重要问题
  Q: C++中的四种存储持续性？(P250)
  Q: C++11中auto和register的作用发生什么变化？(P252)
  Q: 引入名称空间前的存储特性/静态持续变量的三种链接性/static关键词在静态持续变量中两种用法/静态变量的初始化方式？(P254)
  Q: 存储说明符和cv-限定符的作用/const对存储类型的影响？<a id="const">(P260)</a>



## 第10章 对象和类
- 小节标题
  - 10.1 过程性编程和面向对象编程
  - 10.2 抽象和类
  - 10.3 类的构造函数和析构函数
  - 10.4 this指针
  - 10.5 对象数组
  - 10.6 类作用域
  - 10.7 抽象数据类型

- 知识点总结
    - **类**是用户定义的类型，**对象**是类的实例。一般来说，私有**数据成员**存储信息，公有**成员函数**(又称为**方法**)提供访问数据的唯一途径。
    - **作用域解析运算符** :: 、**成员运算法符**. 、**客户/服务器模型**
    - 通常用 :: 将类成员函数在类内声明，在类外定义，声明与定义放在不同的文件，实现封装。
    - 当且仅当没有定义任何构造函数时，编译器才会提供默认**构造函数**。
    - 如果既可以通过初始化，也可以通过赋值来调用构造函数设置对象的值，应采用初始化方法，通常这种方法效率最高。
    ```
        Stock Stock1('A', 9, 20.0)  //隐式调用构造函数
        Stock Stock2 = Stock('B', 3, 20.0)   //显式调用构造函数(可能会创建临时对象)
        Stock *pstock = new Stock('C', 18, 19.0)  //动态分配内存调用构造函数
        Stock3 = Stock('B', 3, 20.0)  //赋值(总会创建临时对象)
    ```
  - 如果构造函数使用了new，则必须使用delete的**析构函数**。
  - 只要类方法不修改调用对象，就应将其声明为const，放在函数括号后面。
  - 每个成员函数(包括构造和析构)都有一个this指针，指向调用对象。
  - 可以使用关键字static在类作用域内定义常量。
  - 通常使用类表示更通用的概念，比如**抽象数据类型**(abstract data type, ADT)

## 第11章 使用类

## 第16章 string类和标准模板库